import cv2import numpy as npimport mathimport matplotlib.pyplot as pltimport configdef weighted_average(dataframe, value, weight):	val = dataframe[value]	wt = dataframe[weight]	return (val * wt).sum() / wt.sum()half_window = 20r_inner = 100r_outter = 370step_radius = 1step_turning = 1class Pulse: #contain	def __init__(self, _name):		self.name = _name		self.dataframe_r = []		self.dataframe_grayscale = []		self.central = None	def add_point(self, r, grayscale):		self.dataframe_r.append(r)		self.dataframe_grayscale.append(grayscale)	def weighted_average(self):		val = np.array(self.dataframe_r)		wt = np.array(self.dataframe_grayscale)		self.central = (val * wt).sum() / wt.sum()		return self.centralclass Ray: #contain	# Pulse_trigger: trigger a pulse when a value greater then (max_light - half_window)	def __init__(self, _img, _centroid_x, _centroid_y, _theta):		self.pulse_index = 0		self.centroid = {'x': _centroid_x,		'y': _centroid_y}		self.theta = _theta		self.parse_info()		self.fetching_status = False		self.pulses = []		self.img = _img		self.rs = {'theta': _theta,				   'rs_list': [],				   'disparity_list': []}	def parse_info(self):		self.max_light= 255		self.half_window = 20	def scan(self):		for r in np.arange(r_inner, r_outter, step_radius):			cur_grayscale = self.img[round(self.centroid['y'] + r*math.sin(self.theta))][round(self.centroid['x'] + r*math.cos(self.theta))][0]			if (self.fetching_status == False) and (cur_grayscale > (self.max_light - self.half_window)): # create a pulse				self.fetch_pulse()			if (self.fetching_status == True) and (cur_grayscale < (self.max_light - self.half_window)): # create a pulse				self.rs['rs_list'].append(self.end_pulse()) # add pluse r			if self.fetching_status:				self.pulse.add_point(r, cur_grayscale)			else:				pass	def fetch_pulse(self):		self.pulse_index += 1		self.pulse = Pulse(str(self.pulse_index))		self.fetching_status = True	def end_pulse(self):		pulse_r = self.pulse.weighted_average()		self.pulses.append(self.pulse)		self.pulse = []		self.fetching_status = False		return pulse_r	def plot(self):		cv2.line(self.img , (self.centroid['x'], self.centroid['y']),				 (round(self.centroid['x'] + r_outter * math.cos(self.theta)), round(self.centroid['y'] + r_outter * math.sin(self.theta))),				 (0, 255, 0))		cv2.circle(self.img, (self.centroid['x'], self.centroid['y']), 50, (0, 255, 0), 2)		# plt.xlabel('x - axis')		# # naming the y axis		# plt.ylabel('y - axis')		#		# # giving a title to my graph		# plt.title('My first graph!')		# for pulse in self.pulses:		#		# 	plt.plot(pulse.dataframe_r, pulse.dataframe_grayscale, color='green', linestyle='dashed', linewidth=3,		# 			 marker='o', markerfacecolor='blue', markersize=12)		#		# 	cv2.circle(self.img, (round(self.centroid['x'] + pulse.central * math.cos(self.theta)),		# 	round(self.centroid['y'] + pulse.central * math.sin(self.theta))), 5, (255, 255, 0), 2)		# function to show the plotclass Scan: #contain	def __init__(self, image_name, _centroid_x, _centroid_y):		self.centroid = {'x': _centroid_x,		'y': _centroid_y}		self.img = cv2.imread(image_name, cv2.IMREAD_COLOR)		self.theta_rs = []	def run(self):		for theta in np.arange(0, 360, step_turning):			m = 1			ray = Ray(self.img, self.centroid['x'], self.centroid['y'], theta * 3.14 / 180)			ray.scan()			self.theta_rs.append(ray.rs)			ray.plot()class Disparity:	def __init__(self):		#self.line = None		self.centroid = {'left':								{'x': 740,								 'y': 400								 },						'right':								{'x': 500,								 'y': 400								 }						 }		self.theta_rs = {'left':[],						'right':[]						 }		self.scans = {'left': None,						'right': None						 }	def plot(self):		for rs_along_ray in self.theta_rs['right']:			for r in rs_along_ray['rs_list']:				cv2.circle(self.scans['right'].img, (round(self.centroid['right']['x'] + r * math.cos(rs_along_ray['theta'])),									  round(self.centroid['right']['y'] + r * math.sin(rs_along_ray['theta']))), 0, (255, 0, 0), 1)		for rs_along_ray in self.theta_rs['left']:			for r in rs_along_ray['rs_list']:				cv2.circle(self.scans['right'].img, (round(self.centroid['right']['x'] + r * math.cos(rs_along_ray['theta'])),									  round(self.centroid['right']['y'] + r * math.sin(rs_along_ray['theta']))), 0, (0, 0, 255), 1)		cv2.imshow('disparity', self.scans['right'].img)		cv2.waitKey(0)	def cal_disparity(self):		theta_i = 0		_len = len(self.theta_rs['left'])		for rs_along_ray in self.theta_rs['right']:			theta_j = 0			for r in rs_along_ray['rs_list']:				fea_x = r * math.cos(rs_along_ray['theta'])				fea_y = r * math.sin(rs_along_ray['theta'])				for search_index in range(-3, 3):					delta_y1 = fea_y - self.theta_rs['left'][np.mod(theta_i + search_index, _len)]['rs_list'][theta_j] \							* math.sin(self.theta_rs['left'][np.mod(theta_i + search_index, _len)]['theta'])					delta_y2 = fea_y - self.theta_rs['left'][np.mod(theta_i + search_index + 1, _len)]['rs_list'][theta_j] \							* math.sin(self.theta_rs['left'][np.mod(theta_i + search_index + 1, _len)]['theta'])					if delta_y1 * delta_y2 <= 0:						slope = delta_y1/(delta_y1 - delta_y2)						x1 = self.theta_rs['left'][np.mod(theta_i + search_index, _len)]['rs_list'][theta_j] \							 * math.cos(self.theta_rs['left'][np.mod(theta_i + search_index, _len)]['theta'])						x2 = self.theta_rs['left'][np.mod(theta_i + search_index + 1, _len)]['rs_list'][theta_j] \							 * math.cos(self.theta_rs['left'][np.mod(theta_i + search_index + 1, _len)]['theta'])						intersect_x = slope * (x2 - x1) + x1						break				if intersect_x is not None:					rs_along_ray['disparity_list'].append(intersect_x - fea_x)				else:					rs_along_ray['disparity_list'].append(None)				theta_j += 1			theta_i += 1	def run(self):		for image_side in ['right', 'left']:			self.scans[image_side] = Scan(config.testing_path + image_side + '_rect.png', self.centroid[image_side]['x'], self.centroid[image_side]['y'])			self.scans[image_side].run()			self.theta_rs[image_side] = self.scans[image_side].theta_rs			cv2.imshow('mono_' + image_side, self.scans[image_side].img)	def extract(self):		# Read image.		img = cv2.imread('mono_left.png', cv2.IMREAD_COLOR)		# Convert to grayscale.		gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)		# Blur using 3 * 3 kernel.		gray_blurred = cv2.blur(gray, (3, 3))		# Apply Hough transform on the blurred image.		detected_circles = cv2.HoughCircles(gray_blurred,											cv2.HOUGH_GRADIENT, 1, 20, param1=50,											param2=30, minRadius=1, maxRadius=40)		# Draw circles that are detected.		if detected_circles is not None:			# Convert the circle parameters a, b and r to integers.			detected_circles = np.uint16(np.around(detected_circles))			for pt in detected_circles[0, :]:				a, b, r = pt[0], pt[1], pt[2]				# Draw the circumference of the circle.				cv2.circle(img, (a, b), r, (0, 255, 0), 2)				# Draw a small circle (of radius 1) to show the center.				cv2.circle(img, (a, b), 1, (0, 0, 255), 3)				cv2.imshow("Detected Circle", img)				cv2.waitKey(0)# Press the green button in the gutter to run the script.# See PyCharm help at https://www.jetbrains.com/help/pycharm/