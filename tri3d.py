import cv2import numpy as npimport mathimport configdef weighted_average(dataframe, value, weight):	val = dataframe[value]	wt = dataframe[weight]	return (val * wt).sum() / wt.sum()half_window = 20r_inner = 500r_outter = 1000class Pulse: #contain	def __init__(self, _name):		self.name = _name		self.dataframe_r = []		self.dataframe_grayscale = []		self.central = None	def add_point(self, r, grayscale):		self.dataframe_r.append(r)		self.dataframe_grayscale.append(grayscale)	def weighted_average(self):		val = np.array(self.dataframe_r)		wt = np.array(self.dataframe_grayscale)		self.central = (val * wt).sum() / wt.sum()		return self.centralclass Ray: #contain	# Pulse_trigger: trigger a pulse when a value greater then (max_light - half_window)	def __init__(self, _img, _centroid_x, _centroid_y, _theta):		self.pulse_index = 0		self.centroid = {'x': _centroid_x,		'y': _centroid_y}		self.theta = _theta		self.parse_info()		self.fetching_status = False		self.pulses = []		self.img = _img		self.rs = {'theta': _theta,				   'rs_list': [],				   '3d_list': []}	def parse_info(self):		self.max_light= 100		self.half_window = 60	def scan(self):		for r in np.arange(r_inner, r_outter, config.step_radius):			cur_grayscale = self.img[round(self.centroid['y'] + r*math.sin(self.theta))][round(self.centroid['x'] + r*math.cos(self.theta))][0]			if (self.fetching_status == False) and (cur_grayscale > (self.max_light - self.half_window)): # create a pulse				self.fetch_pulse()			if (self.fetching_status == True) and (cur_grayscale < (self.max_light - self.half_window)): # create a pulse				self.rs['rs_list'].append(self.end_pulse()) # add pluse r			if self.fetching_status:				self.pulse.add_point(r, cur_grayscale)			else:				pass	def fetch_pulse(self):		self.pulse_index += 1		self.pulse = Pulse(str(self.pulse_index))		self.fetching_status = True	def end_pulse(self):		pulse_r = self.pulse.weighted_average()		self.pulses.append(self.pulse)		self.pulse = []		self.fetching_status = False		return pulse_r	def plot(self):		cv2.line(self.img , (round(self.centroid['x'] + r_inner * math.cos(self.theta)), round(self.centroid['y'] + r_inner * math.sin(self.theta))),				 (round(self.centroid['x'] + r_outter * math.cos(self.theta)), round(self.centroid['y'] + r_outter * math.sin(self.theta))),				 (0, 255, 0))		cv2.circle(self.img, (self.centroid['x'], self.centroid['y']), 50, (0, 255, 0), 2)		# plt.xlabel('x - axis')		# # naming the y axis		# plt.ylabel('y - axis')		#		# # giving a title to my graph		# plt.title('My first graph!')		# for pulse in self.pulses:		#		# 	plt.plot(pulse.dataframe_r, pulse.dataframe_grayscale, color='green', linestyle='dashed', linewidth=3,		# 			 marker='o', markerfacecolor='blue', markersize=12)		#		# 	cv2.circle(self.img, (round(self.centroid['x'] + pulse.central * math.cos(self.theta)),		# 	round(self.centroid['y'] + pulse.central * math.sin(self.theta))), 5, (255, 255, 0), 2)		# function to show the plotclass Scan: #contain	def __init__(self, image, _centroid_x, _centroid_y):		self.centroid = {'x': _centroid_x,		'y': _centroid_y}		self.img = image		self.theta_rs = []	def run(self, show_ray):		for theta in np.arange(0, 360, config.step_turning):			ray = Ray(self.img, self.centroid['x'], self.centroid['y'], theta * 3.14 / 180)			ray.scan()			self.theta_rs.append(ray.rs)			if show_ray:				ray.plot()class Tri3d:	def __init__(self, img):		self.img = img		self.centroid = {			'x': 1024,			'y': 1024		}		self.theta_rs = []		self.scan = None	def plot_cross_point(self):		for rs_along_ray in self.theta_rs:			for r in rs_along_ray['rs_list']:				cv2.circle(self.scan.img, (round(self.centroid['x'] + r * math.cos(rs_along_ray['theta'])),									  round(self.centroid['y'] + r * math.sin(rs_along_ray['theta']))), 0, (255, 0, 0), 1)		#cv2.imshow('disparity', self.scan.img)		#cv2.waitKey(0)	def cal_3d(self):		theta_i = 0		_len = len(self.theta_rs)		for rs_along_ray in self.theta_rs:			theta_j = 0			l_index = 0			for r in rs_along_ray['rs_list']:				l_index += 1				r = r * config.pix_to_physics				fea_x = r * math.cos(rs_along_ray['theta']) * config.ls[str(l_index)] / config.f				if l_index > 24:					l_index = 24				fea_y = config.ls[str(l_index)]				fea_z = r * math.sin(rs_along_ray['theta']) * config.ls[str(l_index)] / config.f				fea_r = r				rs_along_ray['3d_list'].append([fea_x, fea_y, fea_z, fea_r])				theta_j += 1			theta_i += 1		return self.theta_rs	def run(self, show_ray, show_cross_point):		self.scan = Scan(self.img, self.centroid['x'], self.centroid['y'])		self.scan.run(show_ray)		self.theta_rs= self.scan.theta_rs		if show_cross_point:			self.plot_cross_point()		#cv2.imshow('mono_', self.scan.img)# Press the green button in the gutter to run the script.# See PyCharm help at https://www.jetbrains.com/help/pycharm/